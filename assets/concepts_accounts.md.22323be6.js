import{_ as e,v as t,b as a,R as n}from"./chunks/framework.f247d2cd.js";const f=JSON.parse('{"title":"Concept of Accounts","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/accounts.md","filePath":"src/pages/concepts/accounts.md"}'),o={name:"concepts/accounts.md"},s=n(`<h1 id="concept-of-accounts" tabindex="-1">Concept of Accounts <a class="header-anchor" href="#concept-of-accounts" aria-label="Permalink to &quot;Concept of Accounts&quot;">​</a></h1><p>In the context of TVM-compatible blockchains, an account is the fundamental unit of information storage. Each account is uniquely identified by its full address, which is the combination of the workchain identifier and the account identifier. In essence, every account is a smart contract, even a wallet is a simple actor (and smart contract).</p><h2 id="account-structure" tabindex="-1">Account Structure <a class="header-anchor" href="#account-structure" aria-label="Permalink to &quot;Account Structure&quot;">​</a></h2><p>An account is characterized by its address, which is a deterministic value derived from its code and initial data, specifically <code>cell_hash(cell_repr(StateInit))</code>. There are no special types of accounts for user wallets initiating transactions in the TVM blockchain. Wallets are typical smart contracts, and there are many different kinds. Any smart contract that allows the reception of external messages can initiate a transaction.</p><p>The comprehensive account record is represented by a series of nested data structures, including Account Storage, Account State, and Smart Contract Storage (also known as <code>StateInit</code>).</p><h3 id="account-storage-structure" tabindex="-1">Account Storage Structure <a class="header-anchor" href="#account-storage-structure" aria-label="Permalink to &quot;Account Storage Structure&quot;">​</a></h3><p>The outermost structure is the account storage, which encompasses the account balance and the account state. The account state might include the smart contract code and data, which are detailed in the <code>StateInit</code> structure.</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AccountStorage</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  last_trans_lt</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">int</span></span>
<span class="line"><span style="color:#A6ACCD;">  balance</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Tokens</span></span>
<span class="line"><span style="color:#A6ACCD;">  state</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> AccountState</span></span></code></pre></div><p>AccountStorage fields:</p><ul><li><code>last_trans_lt</code>: Logical time of the last transaction</li><li><code>balance</code>: The quantity of cryptocurrency tokens available for the account</li><li><code>state</code>: The present account state</li></ul><h3 id="account-state" tabindex="-1">Account State <a class="header-anchor" href="#account-state" aria-label="Permalink to &quot;Account State&quot;">​</a></h3><p>The account state determines the operation mode of the account while a message is being executed for that account. The Transaction Executor logic significantly varies depending on the current account state.</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">AccountState</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  status</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> AccountStatus</span></span>
<span class="line"><span style="color:#A6ACCD;">  state_init</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Optional</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">StateInit</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">  frozen_state_hash</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Optional</span><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">bytes</span><span style="color:#89DDFF;">]</span></span></code></pre></div><p>AccountState fields:</p><ul><li><code>status</code>: Account status, which can be <code>Uninit</code>, <code>Active</code>, or <code>Frozen</code></li><li><code>state_init</code>: StateInit for the active account</li><li><code>frozen_state_hash</code>: A hash of the last known state for the frozen account</li></ul><h3 id="smart-contract-storage-stateinit" tabindex="-1">Smart Contract Storage (StateInit) <a class="header-anchor" href="#smart-contract-storage-stateinit" aria-label="Permalink to &quot;Smart Contract Storage (StateInit)&quot;">​</a></h3><p>The contract&#39;s byte-code and data are stored within a structure called <code>StateInit</code>. This structure is also used for the initialization of an account when it is uninitialized.</p><div class="language-python"><button title="Copy Code" class="copy"></button><span class="lang">python</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">StateInit</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#A6ACCD;">  code</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Optional</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">Cell</span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#A6ACCD;">  data</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> Optional</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">Cell</span><span style="color:#89DDFF;">]</span></span></code></pre></div><p>StateInit fields:</p><ul><li><code>code</code>: Optional contract code</li><li><code>data</code>: Optional contract data</li></ul><p>The <code>code</code> and <code>data</code> fields encode the current byte-code and data of a contract, where <code>data</code> denotes the values of the contract&#39;s variables.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The representation provided here is a simplified Python representation. In the actual implementation, there are additional fields that are omitted in this library for simplicity.</p></div><h2 id="account-lifecycle" tabindex="-1">Account Lifecycle <a class="header-anchor" href="#account-lifecycle" aria-label="Permalink to &quot;Account Lifecycle&quot;">​</a></h2><h3 id="creation" tabindex="-1">Creation <a class="header-anchor" href="#creation" aria-label="Permalink to &quot;Creation&quot;">​</a></h3><p>Initially, an account does not exist in the blockchain. To create a record of it, we first calculate the address of the future contract (i.e., <code>cell_hash(cell_repr(StateInit))</code>) and send the required amount of native coins to this address with a special flag <code>bounce = false</code>. This flag indicates that if the recipient account does not exist, or if an error occurred during message processing, the coins should remain at this address rather than being sent back with a special error message.</p><p>After this process, we get an account in the blockchain with the status <code>Uninitialized</code>. This means that we have a record of the account in the blockchain, but no data and code.</p><h3 id="activation" tabindex="-1">Activation <a class="header-anchor" href="#activation" aria-label="Permalink to &quot;Activation&quot;">​</a></h3><p>To transition an account to the <code>Active</code> status, we need to send a specially formulated message containing the data and code of this contract. Anyone can send such a message. Validators will verify that the contract address equals <code>cell_hash(cell_repr(StateInit))</code>, and if everything matches, the account will be initialized. This message can also include a function to be called immediately after account activation, along with its arguments. By default, the constructor is called.</p><p>Once the account becomes active, it can accept incoming internal and external messages. Every time an account receives a message, a transaction begins, during which the account can create up to 255 actions such as <code>Internal Messages</code>, <code>External Messages</code>, <code>rawReserve</code>, <code>setCode</code>.</p><h3 id="utilization" tabindex="-1">Utilization <a class="header-anchor" href="#utilization" aria-label="Permalink to &quot;Utilization&quot;">​</a></h3><p>To create a wallet in the network, we simply create a private/public key pair, take the code of our wallet, calculate the address from the code + public key, and send native coins to this address. Once there are coins, we can initialize the wallet and start using it.</p><p>When an account receives a message, the Transaction Executor is launched. Before the contract code execution begins, a storage fee is deducted from the account for all the time that has passed since the previous transaction. The storage fee depends linearly on the size of the contract&#39;s data and code. If the contract&#39;s balance becomes negative after deducting the storage fee, the transaction does not occur, and the account transitions to the <code>Frozen</code> state. In this state, the contract&#39;s data and code are deleted, leaving only the state hash. The contract will remain in the Frozen state until the debt for its storage reaches the deletion threshold. This is a network parameter, currently -0.1. After that, the contract will be permanently deleted without the possibility of recovery.</p><p>Also, during a transaction, a contract can create an outgoing message with a special flag, indicating that all remaining money should be sent with this message, after which the account should be deleted.</p><div class="warning custom-block"><p class="custom-block-title">Caution</p><p>Please note that the storage fee, which depends linearly on the size of the contract&#39;s data and code, is not a one-time payment. This fee is essentially a rental cost for the storage space used by the contract. The fee is charged for the size of the code multiplied by the time elapsed since the last payment.</p></div><h2 id="account-abstraction" tabindex="-1">Account Abstraction <a class="header-anchor" href="#account-abstraction" aria-label="Permalink to &quot;Account Abstraction&quot;">​</a></h2><p>Account Abstraction (AA) is a fundamental concept in TVM blockchains. Unlike certain other blockchain (like a EVM) architectures, where AA is complex and requires changes to core protocol, TVM blockchains have a natively built-in, more user-friendly AA design. This approach is aimed at facilitating extended wallet functionality, enhancing security, and improving user experience.</p><h3 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-label="Permalink to &quot;Overview&quot;">​</a></h3><p>In this framework, whether it&#39;s a native coin or a TIP-3 token, value can only move as an outcome of smart contract code execution. There are no Externally Owned Accounts (EOA), just Accounts, which are &quot;abstract&quot;.</p><p>An account is deployed with some initial state (code + data), and the TVM includes instructions to access and modify accounts&#39; code, state, send messages, deploy new accounts, and more. Executing the code in the TVM is initiated by an inbound message.</p><h3 id="interaction" tabindex="-1">Interaction <a class="header-anchor" href="#interaction" aria-label="Permalink to &quot;Interaction&quot;">​</a></h3><p>Users communicate with accounts by sending External Messages, using key pairs. With no EOAs, these External Messages do not carry any value. On receipt of an External Message, the TVM provides a small portion of &quot;credit gas&quot; to perform specific logic before accepting the message. Each Account can be seen as its own EntryPoint.</p><h3 id="account-address" tabindex="-1">Account Address <a class="header-anchor" href="#account-address" aria-label="Permalink to &quot;Account Address&quot;">​</a></h3><p>Each account is content-addressable, with the account address derived from its initial code and state. This approach enables developers to build secure systems with address-based access control rules, without the need to maintain explicit access control lists.</p><h3 id="upgrading" tabindex="-1">Upgrading <a class="header-anchor" href="#upgrading" aria-label="Permalink to &quot;Upgrading&quot;">​</a></h3><p>On TVM, the <code>SETCODE</code> instruction allows an account to self-upgrade using any code it can obtain from an inbound message or its own storage. This way, accounts&#39; addresses remain unchanged, and the upgrade requires no additional deployments.</p><h2 id="smart-contract-wallets" tabindex="-1">Smart Contract Wallets <a class="header-anchor" href="#smart-contract-wallets" aria-label="Permalink to &quot;Smart Contract Wallets&quot;">​</a></h2><p>The driving force behind AA is to give developers the power to implement the ownership model, based on the concept that &quot;code is law&quot;.</p><p>For TVM blockchains, formally verified implementations for singlesig/multisig are available, along with an upgradable version. This facilitates the creation of any logic and integration on top, keeping the address unchanged.</p>`,48),c=[s];function i(r,l,d,h,p,u){return t(),a("div",null,c)}const y=e(o,[["render",i]]);export{f as __pageData,y as default};
