import{_ as s,v as t,b as n,E as o,R as e,M as l}from"./chunks/framework.f247d2cd.js";const C=JSON.parse('{"title":"Data Representation","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/data-representation.md","filePath":"src/pages/concepts/data-representation.md"}'),r={name:"concepts/data-representation.md"},c=e('<h1 id="data-representation" tabindex="-1">Data Representation <a class="header-anchor" href="#data-representation" aria-label="Permalink to &quot;Data Representation&quot;">​</a></h1><p>In the context of TVM (TON Virtual Machine) based blockchains, data representation plays a crucial role. This document aims to provide a comprehensive overview of how data is represented and stored in these blockchains.</p><p>At the most basic level, everything in a blockchain is stored in a structure called a <code>cell</code>. A cell can contain up to <strong>1023 data bits</strong> and <strong>up to 4 references</strong> to other cells. Any value can be represented as a tree of cells. The specific structure for representing various data types is described in the ABI specification.</p><h2 id="cells-the-fundamental-units-of-data" tabindex="-1">Cells: The Fundamental Units of Data <a class="header-anchor" href="#cells-the-fundamental-units-of-data" aria-label="Permalink to &quot;Cells: The Fundamental Units of Data&quot;">​</a></h2><p>Importantly, cyclic references between cells are not allowed. As a result, all cells form a directed acyclic graph (<code>DAG</code>), where each cell can be viewed as an individual node in the graph.</p><p>The diagram below illustrates this concept, showing how the cells interconnect to form a DAG structure.</p>',6),i=e(`<h2 id="constraints-on-cell-structure" tabindex="-1">Constraints on Cell Structure <a class="header-anchor" href="#constraints-on-cell-structure" aria-label="Permalink to &quot;Constraints on Cell Structure&quot;">​</a></h2><p>While the cell structure provides a flexible way to store data, there are some constraints on the overall structure:</p><ul><li>The maximum depth of the tree of cells is <strong>2<sup>16</sup></strong>.</li><li>For external messages, the maximum tree depth is limited to <strong>512</strong>.</li></ul><h2 id="example-of-data-representation" tabindex="-1">Example of Data Representation <a class="header-anchor" href="#example-of-data-representation" aria-label="Permalink to &quot;Example of Data Representation&quot;">​</a></h2><p>For example, a tuple <code>(uint32, bool, uint32[])</code> with values <code>(0x539, true, [0x0B, 0x16])</code> can be represented as a tree of cells as shown in the example below:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Ordinary   l: 000   bits: 66   refs: 1   data: 00000539800000016_</span></span>
<span class="line"><span style="color:#A6ACCD;">hashes: 29a11f1e37e0c64354f52be1f517992639e91a7d07487630c1e3800a479277ba</span></span>
<span class="line"><span style="color:#A6ACCD;">depths: 2</span></span>
<span class="line"><span style="color:#A6ACCD;">  └─Ordinary   l: 000   bits: 9   refs: 2   data: cfc_</span></span>
<span class="line"><span style="color:#A6ACCD;">  hashes: a590c29333e1d2060a079b8bd1f8f57a56408d87e1586ccbe6caa888ae34abc0</span></span>
<span class="line"><span style="color:#A6ACCD;">  depths: 1</span></span>
<span class="line"><span style="color:#A6ACCD;">  ├─Ordinary   l: 000   bits: 34   refs: 0   data: 00000002e_</span></span>
<span class="line"><span style="color:#A6ACCD;">  │ hashes: 3d10b2cb5aa6f262a35dc82a384d326f9b3667c1c8002021382987a88ca8482b</span></span>
<span class="line"><span style="color:#A6ACCD;">  │ depths: 0</span></span>
<span class="line"><span style="color:#A6ACCD;">  └─Ordinary   l: 000   bits: 34   refs: 0   data: 00000005a_</span></span>
<span class="line"><span style="color:#A6ACCD;">    hashes: 43bd1f7b6ad2214e74ff517098fc7c45b9acd979b0da5e0cc804f6af313ce474</span></span>
<span class="line"><span style="color:#A6ACCD;">    depths: 0</span></span></code></pre></div><p>This representation can be encoded as a <code>base64</code> string for transmission or storage.</p><h2 id="boc-bag-of-cells" tabindex="-1">BOC (Bag of Cells) <a class="header-anchor" href="#boc-bag-of-cells" aria-label="Permalink to &quot;BOC (Bag of Cells)&quot;">​</a></h2><p>The Bag of Cells (BOC) is a universal format for data packaging in TVM. Every object — account, transaction, message, block — is stored in the blockchain database as BOCs. The BOC of a block includes BOCs of all messages and transactions that were executed in this block.</p><h2 id="cell-types-and-flavors" tabindex="-1">Cell Types and Flavors <a class="header-anchor" href="#cell-types-and-flavors" aria-label="Permalink to &quot;Cell Types and Flavors&quot;">​</a></h2><p>There are five types of cells: <code>ordinary</code> and four <code>exotic</code> types, which include:</p><ul><li>Pruned branch cells</li><li>Library reference cells</li><li>Merkle proof cells</li><li>Merkle update cells</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>For more on exotic cells see: <a href="https://ton.org/tvm.pdf" target="_blank" rel="noreferrer">TVM Whitepaper, Section 3</a>.</p></div><p>Cells also come in different &quot;flavors&quot; for different purposes:</p><ul><li><strong>Builder</strong>: for partially constructed cells, allowing fast operations for appending bitstrings, integers, other cells, and references to other cells.</li><li><strong>Slice</strong>: for &#39;dissected&#39; cells representing either the remainder of a partially parsed cell or a value (subcell) residing inside such a cell.</li></ul><h2 id="serialization-of-data-to-cells" tabindex="-1">Serialization of Data to Cells <a class="header-anchor" href="#serialization-of-data-to-cells" aria-label="Permalink to &quot;Serialization of Data to Cells&quot;">​</a></h2><p>Any object in a blockchain (message, message queue, block, whole blockchain state, contract code, and data) serializes to a cell. The serialization process is described by a <code>TL-B</code> scheme, which is a formal description of how an object can be serialized into a <code>Builder</code> or parsed from a <code>Slice</code>.</p><p>In conclusion, data representation in blockchain is a complex but efficient process, allowing for compact storage and flexibility in data structures. Understanding this process is crucial for anyone working with these blockchains.</p><h2 id="cost-of-data-storage-in-cells" tabindex="-1">Cost of Data Storage in Cells <a class="header-anchor" href="#cost-of-data-storage-in-cells" aria-label="Permalink to &quot;Cost of Data Storage in Cells&quot;">​</a></h2><p>Storing data in a blockchain&#39;s cells is associated with costs, and the contract pays for the storage of both bits and references. These costs are crucial to understand, as they influence how data structures are described and organized.</p><ul><li>In the <code>masterchain</code>, each bit costs 1000 units, and every reference costs 500,000 units.</li><li>In the <code>base workchain</code>, each bit costs 1 unit, and every reference costs 500 units.</li></ul><p>The exact values can be found in the 18th parameter of the network config, and these costs might vary among different TVM chains.</p><h3 id="example-storage-fees-on-everscale" tabindex="-1">Example: Storage Fees on Everscale <a class="header-anchor" href="#example-storage-fees-on-everscale" aria-label="Permalink to &quot;Example: Storage Fees on Everscale&quot;">​</a></h3><p>In the Everscale network, a specific example of a TVM chain, the storage fees for each smart contract are calculated as:</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">storage_fees = CEIL(</span></span>
<span class="line"><span style="color:#A6ACCD;">   (</span></span>
<span class="line"><span style="color:#A6ACCD;">       account.bits * global_bit_price</span></span>
<span class="line"><span style="color:#A6ACCD;">       + account.cells * global_cell_price</span></span>
<span class="line"><span style="color:#A6ACCD;">   ) * period / 2 ^ 16</span></span>
<span class="line"><span style="color:#A6ACCD;">)</span></span></code></pre></div><p>Here:</p><ul><li><code>account.bits</code> and <code>account.cells</code>: Number of bits and cells in the smart contract, including code and data.</li><li><code>global_bit_price</code>: Price for storing one bit (p18 for both masterchain and workchains).</li><li><code>global_cell_price</code>: Price for storing one cell (p18 for both masterchain and workchains).</li><li><code>period</code>: Number of seconds a smart contract is stored for.</li></ul><p>A cell can contain no more than 1023 bits and 4 references, and more complex data structures may require more cells to store the same amount of data.</p><p>An example calculation for storing 1062.5 KB of data for one day in Everscale is given <a href="https://everscan.io/accounts/0:cd0b3e21ea59fc43a8343f935c7e74b4c22e3ba43f5e08410ffa371cedfe3dee" target="_blank" rel="noreferrer">here</a>. The minimum storage fee would be 0.014291591 EVERs.</p><div class="warning custom-block"><p class="custom-block-title">Note</p><p>If there are insufficient funds to cover the storage fee, the smart contract will be frozen, its balance reduced to zero, and the remaining fee marked as debt.</p></div>`,30);function d(p,h,f,u,b,m){const a=l("BDKImgContainer");return t(),n("div",null,[c,o(a,{src:"./../dag-diagram.png",maxWidth:"50%",altText:"directed acyclic graph",padding:"20px 0 20px 0"}),i])}const y=s(r,[["render",d]]);export{C as __pageData,y as default};
