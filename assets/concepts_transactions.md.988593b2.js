import{_ as s,v as i,b as c,E as t,F as e,L as n,R as o,M as r}from"./chunks/framework.f247d2cd.js";const x=JSON.parse('{"title":"Concept of Transaction Finalization","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"concepts/transactions.md","filePath":"src/pages/concepts/transactions.md"}'),h={name:"concepts/transactions.md"},l=e("h1",{id:"concept-of-transaction-finalization",tabindex:"-1"},[n("Concept of Transaction Finalization "),e("a",{class:"header-anchor",href:"#concept-of-transaction-finalization","aria-label":'Permalink to "Concept of Transaction Finalization"'},"​")],-1),d=e("p",null,"In the world of blockchain technology, the concept of transaction finalization is pivotal. It refers to the process of confirming and validating transactions within the network, ensuring their immutability and integration into the blockchain. This document aims to delve deeper into the specifics of transaction finalization in the context of TVM-compatible blockchains, which operate based on a pure actor model.",-1),u=e("h2",{id:"actor-model-async-transactions",tabindex:"-1"},[n("Actor Model & Async Transactions "),e("a",{class:"header-anchor",href:"#actor-model-async-transactions","aria-label":'Permalink to "Actor Model & Async Transactions"'},"​")],-1),p=e("p",null,"TVM-compatible blockchains operate based on the pure actor model, an asynchronous and concurrent computational model. Within this system, each contract functions as an independent actor, processing its individual messages. The execution of a smart contract or a transaction within a single contract is a synchronous atomic operation. However, when an operation involves multiple contracts, interactions between them can occur asynchronously.",-1),m=o('<p>For instance, let&#39;s imagine <code>Contract A</code> calling <code>Contract B</code>. In many other blockchain models, if <code>Contract B</code> runs out of gas during execution, the entire transaction would be rolled back, including the state changes in <code>Contract A</code> that occurred prior to the call. However, in the actor model of TVM blockchains, if <code>Contract B</code> encounters an error, the changes <code>Contract A</code> made before calling <code>Contract B</code> would persist. The execution failure of <code>Contract B</code> only rolls back changes related to <code>Contract B</code>&#39;s execution. This characteristic ensures a higher degree of reliability and security in transaction processing.</p><h2 id="transaction-flows" tabindex="-1">Transaction Flows <a class="header-anchor" href="#transaction-flows" aria-label="Permalink to &quot;Transaction Flows&quot;">​</a></h2><p>Transactions in these blockchains are part of a continuous, asynchronous process where numerous actors interact, process messages, and modify states. Each smart contract (actor) follows a specific behavior pattern, responding to events, executing its code, modifying its own properties, optionally generating outgoing messages, and then going into standby mode until the next event occurs. These sequences form an <code>AccountChain</code>, a chain of transactions for a single account, which is then included in a block without disrupting the sequencing.</p><p>When considering multiple accounts, we have multiple <code>AccountChains</code> forming a <code>ShardChain</code>, which can be dynamically split and merged depending on the transaction load. Ultimately, all shards that contain all accounts following a set of rules form a Blockchain, where multiple blockchains can operate simultaneously and interact with each other.</p><h2 id="logical-time-in-transactions" tabindex="-1">Logical Time in Transactions <a class="header-anchor" href="#logical-time-in-transactions" aria-label="Permalink to &quot;Logical Time in Transactions&quot;">​</a></h2><p>Every transaction within the TVM-compatible blockchain is assigned a logical time interval. This logical time serves as a unique identifier for transactions and outbound messages of an account. The logical time intervals of transactions of the same account do not intersect each other, thus ensuring that all outbound messages generated by an account are unique and identifiable.</p><h2 id="components-of-a-transaction" tabindex="-1">Components of a Transaction <a class="header-anchor" href="#components-of-a-transaction" aria-label="Permalink to &quot;Components of a Transaction&quot;">​</a></h2><p>Each transaction within the TVM-compatible blockchain contains or indirectly refers to the following data:</p><ul><li>The account to which the transaction belongs.</li><li>The logical time of the transaction.</li><li>An inbound message processed by the transaction. Each transaction is always initiated by this message.</li><li>The number of generated outbound messages.</li><li>The outbound messages themselves.</li><li>The initial and final state of the account, including its balance.</li><li>The total fees collected by the validators.</li><li>A detailed description of the transaction containing all or some data needed to validate it.</li></ul><h2 id="types-of-transactions" tabindex="-1">Types of Transactions <a class="header-anchor" href="#types-of-transactions" aria-label="Permalink to &quot;Types of Transactions&quot;">​</a></h2><p>There are different types of transactions allowed in the blockchain, each serving a unique purpose:</p><ul><li><strong>Ordinary transactions:</strong> These belong to an account and process exactly one inbound message, compute the new state of the account, and generate several outbound messages.</li><li><strong>Storage transactions:</strong> These transactions do not process any inbound message and do not invoke any code. Their only effect is to collect storage payments from an account, affecting its storage statistics and its balance.</li><li><strong>Tick and Tock transactions:</strong> These are automatically invoked for certain special accounts in the masterchain that have the tick flag set in their state, as the very first transactions in every masterchain block or the very last transactions in every masterchain block.</li><li><strong>Split and Merge transactions:</strong> These are invoked as the last transactions of shardchain blocks immediately preceding a shardchain split event or immediately after a shardchain merge event, if an instance of a large smart contract needs to be merged with another instance of the same smart contract.</li></ul><h2 id="transaction-phases" tabindex="-1">Transaction Phases <a class="header-anchor" href="#transaction-phases" aria-label="Permalink to &quot;Transaction Phases&quot;">​</a></h2><p>In the TVM blockchain, transactions are processed through several distinct phases. Each phase plays a critical role in executing and validating transactions. Understanding these phases can provide a more comprehensive view of how transactions function in the blockchain.</p><h3 id="storage-phase" tabindex="-1">Storage Phase <a class="header-anchor" href="#storage-phase" aria-label="Permalink to &quot;Storage Phase&quot;">​</a></h3><p>The Storage Phase is the initial stage of every transaction. During this phase, the blockchain calculates storage fees accrued by the smart contract due to the occupation of some space in the chain state. This storage fee is calculated based on the amount of storage used by the smart contract, represented in bytes and the duration, in seconds, for which the storage has been used.</p><p>The formula for calculating the storage fee is</p><p><code>(cells_count * cell_price + bits_count * bit_price) / 2^16 * time_delta</code>.</p><p>If the smart contract did not exist before, the storage phase is absent.</p><h3 id="credit-phase" tabindex="-1">Credit Phase <a class="header-anchor" href="#credit-phase" aria-label="Permalink to &quot;Credit Phase&quot;">​</a></h3><p>Following the Storage Phase is the Credit Phase. During this phase, the account balance is calculated with respect to a possible incoming message value and the collected storage fee.</p><h2 id="compute-phase" tabindex="-1">Compute Phase <a class="header-anchor" href="#compute-phase" aria-label="Permalink to &quot;Compute Phase&quot;">​</a></h2><p>The Compute Phase is where the TVM executes the smart contract code invoked by a message. In this phase, all computations and state updates of the contract that do not interact with other contracts occur. The Compute Phase is deterministic, and its outcome is solely dependent on the input data and the current state of the smart contract. This phase executes in an isolated environment to ensure the integrity and security of the computations. If an exception occurs during the Compute Phase, such as an out-of-gas error, the entire transaction is aborted, and the subsequent phases do not commence. At the end of this phase, the TVM prepares a set of &quot;output actions&quot; for dispatch during the Action Phase.</p><h3 id="action-phase" tabindex="-1">Action Phase <a class="header-anchor" href="#action-phase" aria-label="Permalink to &quot;Action Phase&quot;">​</a></h3><p>The Action Phase is where the output messages created during the Compute Phase are dispatched. Actions that may occur during this phase include calling other smart contracts and any other actions specified in the output messages.</p><p>These calls can lead to various outcomes such as token transfers and state changes of the receiving contract. The Action Phase enables the smart contract&#39;s interaction with other contracts within the blockchain network. However, the actual state changes only occur if the Action Phase is successfully completed.</p>',26),g=o('<div class="warning custom-block"><p class="custom-block-title">Caution</p><p>Please note that there&#39;s a maximum limit of 255 actions that can be dispatched during the Action Phase. This limit includes <code>internal outbound messages</code>, <code>event messages</code>, <code>rawReserve</code>, <code>setCode</code>. Exceeding this limit will cause the transaction to be aborted.</p></div><h3 id="bounce-phase" tabindex="-1">Bounce Phase <a class="header-anchor" href="#bounce-phase" aria-label="Permalink to &quot;Bounce Phase&quot;">​</a></h3><p>The Bounce Phase occurs if the transaction is aborted, for instance, due to a failure in the Compute or Action phases, and the inbound message has its bounce flag set. In this phase, the inbound message is &quot;bounced&quot; by automatically generating an outbound message to its original sender. Almost all value of the original inbound message is transferred to the generated message, which otherwise has an empty body.</p><p>Each of these phases plays a crucial role in ensuring the security, reliability, and efficiency of transactions within the TVM-compatible blockchain. Gaining a thorough understanding of these phases can provide a more complete picture of transaction processing in the blockchain.</p>',4);function f(b,y,T,v,w,k){const a=r("BDKImgContainer");return i(),c("div",null,[l,d,u,p,t(a,{src:"./../transaction-finalization.png",padding:"20px 0 20px 0"}),m,t(a,{src:"./../compute-and-action-phases.png",padding:"20px 0 20px 0"}),g])}const C=s(h,[["render",f]]);export{x as __pageData,C as default};
