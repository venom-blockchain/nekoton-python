import{_ as e,v as a,b as t,R as s}from"./chunks/framework.f247d2cd.js";const g=JSON.parse('{"title":"Concept of Internal & External Messages","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"concepts/messages.md","filePath":"src/pages/concepts/messages.md"}'),n={name:"concepts/messages.md"},o=s(`<h1 id="concept-of-internal-external-messages" tabindex="-1">Concept of Internal &amp; External Messages <a class="header-anchor" href="#concept-of-internal-external-messages" aria-label="Permalink to &quot;Concept of Internal &amp; External Messages&quot;">​</a></h1><p>In TON Virtual Machine (TVM) blockchains, messages are integral to facilitating interactions between smart contracts or between smart contracts and external applications. Messages essentially serve as the main communication medium, enabling contracts to execute various operations. Messages are categorized into three types:</p><ul><li>External Inbound Messages</li><li>Internal Messages</li><li>External Outbound Messages</li></ul><h2 id="external-inbound-messages" tabindex="-1">External Inbound Messages <a class="header-anchor" href="#external-inbound-messages" aria-label="Permalink to &quot;External Inbound Messages&quot;">​</a></h2><p>External inbound messages are a type of communication in blockchain technology that originate outside the blockchain. These messages are used to deploy and call contracts, and they do not carry any value nor a source address, but do possess a destination address. Importantly, they are allocated a gas credit of 10k by validators. This gas credit is crucial for the execution of the transaction, as it invokes the contract and passes on the message.</p><p>In TVM, these are also known as inbound external messages and they initiate changes to the blockchain&#39;s state. It&#39;s important to note that external messages cannot be value-bearing. They can only declare intent to transfer value to another account.</p><p>The concept of gas credit is best illustrated by considering wallet contracts. In this context, gas credit is used to verify that a message is signed with the owner&#39;s key. If this verification fails, the <code>tvm.accept()</code> method is not invoked, the transaction fails, and the wallet does not spend any money, i.e., it does not pay the 10k gas credit.</p><p>The <code>tvm.accept()</code> method is a mechanism used to confirm that the contract agrees to pay for the transaction from its account within the 10k gas credit limit. If <code>tvm.accept()</code> is invoked, the transaction continues, and the contract can create additional outbound messages. However, if an exception occurs, or the contract does not invoke <code>tvm.accept()</code>, or the gas credit runs out, the message is discarded and does not enter the blockchain.</p><p>Here&#39;s a simple example of a function that uses the <code>tvm.accept()</code> method:</p><div class="language-solidity"><button title="Copy Code" class="copy"></button><span class="lang">solidity</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">set</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">uint</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">_value</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">external</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">checkOwnerAndAccept</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">require</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">msg</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pubkey</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> tvm</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pubkey</span><span style="color:#89DDFF;">(),</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">102</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">  tvm</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">accept</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">  variable </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> _value</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="replay-protection" tabindex="-1">Replay Protection <a class="header-anchor" href="#replay-protection" aria-label="Permalink to &quot;Replay Protection&quot;">​</a></h2><p>Replay protection is essential in a blockchain environment, especially in the context of external inbound messages. Without replay protection, the same external message could be included in the blockchain an indefinite number of times, as long as the contract agrees to pay for it. Therefore, each contract must implement its own replay protection mechanism.</p><p>In the TON Solidity compiler, a simple built-in replay protection mechanism is provided. This mechanism includes a hidden static variable, <code>uint64 timestamp</code>, which records the time of the last external message. The compiler generates a check that verifies whether the time of the last accepted message is less than that of the new one, and updates the time accordingly.</p><p>However, this built-in protection is quite primitive and may not work well if many external messages are sent in parallel. Moreover, if your contract has errors that occur after <code>tvm.accept()</code>, the transaction will fail, and the contract state will be rolled back to the beginning. This means that the timestamp will not be updated, and the validator can include this external message as many times as they want, as long as there are coins on the contract balance or the message has not expired.</p><p>In such circumstances, you may want to consider implementing your own replay protection by declaring a special function called <a href="https://github.com/tonlabs/TON-Solidity-Compiler/blob/master/API.md#aftersignaturecheck" target="_blank" rel="noreferrer"><code>afterSignatureCheck</code></a>.</p><p>To prevent this, it&#39;s recommended to perform all checks before invoking <code>tvm.accept()</code>. Also, when sending value, use flag + 2 where possible. This means that if any errors occur during the sending of this message, such a message should simply be ignored. Alternatively, make sure you have enough coins for sending.</p><p>In addition to the <code>AbiHeader time</code> pragma, there are also:</p><ul><li><code>AbiHeader expire</code>: This pragma adds an expire header, instructing the SDK to add to the message the time after which this message is considered invalid, and the compiler checks it against the block time.</li><li><code>AbiHeader pubkey</code>: This pragma instructs the SDK/compiler that all external messages must be signed with a private key, and the compiler adds a signature check. The signature doesn&#39;t necessarily have to be from the same public key set as <code>tvm.pubkey()</code>. The SDK can sign with any pair of keys and attach the public key to check the signature to the message. Therefore, we do a <code>tvm.pubkey() == msg.pubkey()</code> check when receiving external messages. This pragma should always be added if you will be receiving external messages.</li></ul><p>Remember, the goal of these mechanisms is to ensure the integrity and security of the transactions within the blockchain.</p><h2 id="internal-messages" tabindex="-1">Internal Messages <a class="header-anchor" href="#internal-messages" aria-label="Permalink to &quot;Internal Messages&quot;">​</a></h2><p>Internal messages facilitate communication between smart contracts within the blockchain. They contain both a source and a destination address and can carry value. They enable contracts to interact with each other and perform operations like invoking methods and transferring value.</p><p>Each internal message is unique, containing its full source address along with its logical creation time. Outbound messages created by the same smart contract have strictly increasing logical creation times, enabling you to find a message by its hash. The order of internal messages is preserved by their logical time, and their delivery is guaranteed.</p><p>The <code>dest.transfer(value)</code> function creates an internal message with a value in Native Coins, which invokes the <code>receive()</code> function in the receiving contract without any data.</p><p>In blockchain, these are simply referred to as internal messages. They update the blockchain&#39;s state and can be value-bearing. The header of an internal message contains information such as source and destination addresses, the amount of coins attached to the message, message delivery fee amount, and message creation logic time and epoch creation time.</p><div class="warning custom-block"><p class="custom-block-title">Note</p><p>It&#39;s critical to note that all interactions between contracts are asynchronous. The blockchain guarantees that a sent internal message will be delivered, strictly in one copy, and if a contract A sends multiple messages to contract B, they will be delivered strictly in the order of sending. However, there are no guarantees regarding the timing of delivery. The blockchain does not guarantee the delivery of external messages.</p></div><h2 id="external-outbound-messages" tabindex="-1">External Outbound Messages <a class="header-anchor" href="#external-outbound-messages" aria-label="Permalink to &quot;External Outbound Messages&quot;">​</a></h2><p>External outbound messages are events that contracts emit for the outside world. While they typically contain a source address, they do not necessarily have a destination address, nor do they carry any value. Despite this, the destination field can still be specified in these messages. However, it&#39;s important to note that even if a destination is provided, the message won&#39;t be sent to that address within the blockchain. The inclusion of this field can be useful for off-chain indexing purposes. These messages are critical for implementing off-chain logic. You can subscribe to these messages and perform off-chain actions whenever you receive them.</p><p>In blockchain, these are also known as outbound external messages or events. They can be emitted by a smart contract and off-chain participants can subscribe to these events within the network and receive them. The source address is automatically assigned to be equal to the smart contract address emitting the event. The destination address may contain any identifier. It is included for easier integration with off-chain applications, i.e. applications can monitor emitted events based on their destination address, and consume only those events destined to their custom identifier.</p><p>Each message, regardless of its type, can contain a body which is an arbitrary cell. This cell is used for function input/output or event data.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>All functions can be executed either via external or internal messages. However, the way they handle return values differs based on whether a function is marked as <code>responsible</code> or not. The <code>responsible</code> modifier is a feature that helps manage return values when functions are invoked. It doesn&#39;t cause the function to return a value directly. Instead, it automatically generates a callback that invokes the specified function with the return arguments.</p></div><h2 id="non-bounceable-messages" tabindex="-1">Non-bounceable Messages <a class="header-anchor" href="#non-bounceable-messages" aria-label="Permalink to &quot;Non-bounceable Messages&quot;">​</a></h2><p>Most internal messages sent between smart contracts should be bounceable, i.e., should have their &quot;bounce&quot; bit set. Then, if the destination smart contract does not exist, or if it throws an unhandled exception while processing this message, the message will be &quot;bounced&quot; back carrying the remainder of the original value (minus all message transfer and gas fees). However, on some occasions, non-bounceable internal messages must be used. For instance, new accounts cannot be created without at least one non-bounceable internal message being sent to them.</p><p>In blockchain, the &quot;bounced&quot; flag is set when the message itself was auto-generated as a result of an error. If the message with a bounced flag leads to an error itself, the next bounced message will not be generated.</p><div class="info custom-block"><p class="custom-block-title">Note</p><p>The query contained in the body of a bounced message should never be executed.</p></div><div class="tip custom-block"><p class="custom-block-title">Note</p><p>It is a good idea not to allow the end user (e.g., of a wallet) to send unbounceable messages containing large amounts of value or to warn them if they do. It is a better idea to send a small amount first, then initialize the new smart contract, and then send a larger amount.</p></div>`,35),i=[o];function r(c,l,d,h,p,m){return a(),t("div",null,i)}const b=e(n,[["render",r]]);export{g as __pageData,b as default};
